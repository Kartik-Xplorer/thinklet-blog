import { addArticleJsonLd } from '@starter-kit/utils/seo/addArticleJsonLd';
import { addPublicationJsonLd } from '@starter-kit/utils/seo/addPublicationJsonLd';
import {
	getAutogeneratedPostOG,
	getAutogeneratedPublicationOG,
} from '@starter-kit/utils/social/og';
import request from 'graphql-request';
import { GetStaticPaths, GetStaticProps } from 'next';
import Head from 'next/head';
import { useRef } from 'react';
import { twJoin } from 'tailwind-merge';
import { Container } from '../components/container';
import { AppProvider } from '../components/contexts/appContext';
import { Header } from '../components/header';
import { Layout } from '../components/layout';
import { PostHeader } from '../components/post-header';
import PostPageNavbar from '../components/post-page-navbar';
import PublicationFooter from '../components/publication-footer';
import StaticPageContent from '../components/static-page-content';
import {
	MorePostsByPublicationDocument,
	MorePostsEdgeFragment,
	PageByPublicationDocument,
	PostFullFragment,
	PublicationFragment,
	SinglePostByPublicationDocument,
	SlugPostsByPublicationDocument,
	StaticPageFragment,
	TagPostsByPublicationDocument,
} from '../generated/graphql';
import { generateBreadcrumbSchema } from '../utils/seo/breadcrumb-schema';

type PostProps = {
	type: 'post';
	post: PostFullFragment;
	publication: PublicationFragment;
	morePosts: MorePostsEdgeFragment[];
	recommendedPosts: MorePostsEdgeFragment[];
};

type PageProps = {
	type: 'page';
	page: StaticPageFragment;
	publication: PublicationFragment;
};

type Props = PostProps | PageProps;

const Post = ({ publication, post, morePosts, recommendedPosts }: PostProps) => {
	const highlightJsMonokaiTheme =
		'.hljs{display:block;overflow-x:auto;padding:.5em;background:#23241f}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}';

	const title = post.seo?.title || post.title;
	const description = post.seo?.description || post.brief || post.content.markdown.substring(0, 150);
	const image = post.coverImage?.url || publication.preferences.logo;
	const canonical = post.url;

	const breadcrumbSchema = generateBreadcrumbSchema([
		{ name: 'Home', item: publication.url },
		...(post.tags && post.tags.length > 0
			? [{ name: post.tags[0].name, item: `${publication.url}/tag/${post.tags[0].slug}` }]
			: []),
		{ name: post.title, item: `${publication.url}/${post.slug}` },
	]);

	return (
		<>
			<Head>
				<title>{title}</title>
				<meta name="description" content={description} />
				<meta property="og:title" content={title} />
				<meta property="og:description" content={description} />
				<meta property="og:image" content={image || undefined} />
				<meta property="twitter:card" content="summary_large_image" />
				<meta property="twitter:title" content={title} />
				<meta property="twitter:description" content={description} />
				<meta property="twitter:image" content={image || undefined} />
				<link rel="canonical" href={canonical} />
				<script
					type="application/ld+json"
					dangerouslySetInnerHTML={{ __html: breadcrumbSchema }}
				/>
				<script
					type="application/ld+json"
					dangerouslySetInnerHTML={{
						__html: JSON.stringify(addArticleJsonLd(publication, post)),
					}}
				/>
				<style dangerouslySetInnerHTML={{ __html: highlightJsMonokaiTheme }}></style>
			</Head>
			<PostHeader post={post} morePosts={morePosts} recommendedPosts={recommendedPosts} />
		</>
	);
};

const Page = ({ page }: PageProps) => {
	const title = page.title;
	return (
		<>
			<Head>
				<title>{title}</title>
			</Head>
			<div className="blog-page-area mx-auto min-h-screen px-4 py-8 md:w-2/3 md:p-10">
				<StaticPageContent pageContent={page} />
			</div>
		</>
	);
};

export default function PostOrPage(props: Props) {
	const headerRef = useRef<HTMLElement | null>(null);
	const maybePost = props.type === 'post' ? props.post : null;
	const maybePage = props.type === 'page' ? props.page : null;
	const publication = props.publication;
	const navPositionStyles =
		'relative transform-none md:sticky md:top-0 md:left-0 md:backdrop-blur-lg';

	if (props.type === 'post') {
		return (
			<AppProvider publication={publication} post={props.post}>
				<Layout>
					<header
						ref={headerRef}
						className={twJoin(
							'blog-header',
							'z-50 w-full border-b',
							navPositionStyles,
							'border-black/10 bg-white bg-opacity-70 dark:border-white/10 dark:bg-slate-900 dark:bg-opacity-70',
						)}
					>
						<PostPageNavbar publication={publication} ref={headerRef} />
					</header>
					<Container>
						<article className="flex flex-col items-start gap-10 pb-10">
							<Post {...props} />
						</article>
					</Container>
					<PublicationFooter
						authorName={publication.author.name}
						title={publication.title}
						imprint={publication.imprint}
						disableFooterBranding={publication.preferences.disableFooterBranding}
						isTeam={publication.isTeam}
						logo={publication.preferences.logo}
						darkMode={publication.preferences.darkMode}
					/>
				</Layout>
			</AppProvider>
		);
	}

	const description =
		publication.descriptionSEO || publication.title || `${publication.author.name}'s Blog`;

	return (
		<AppProvider publication={publication} post={maybePost} page={maybePage}>
			<Layout>
				<Head>
					<title>
						{publication.displayTitle || publication.title || 'Hashnode Blog Starter Kit'}
					</title>
					<meta name="description" content={description} />
					<meta property="twitter:card" content="summary_large_image" />
					<meta
						property="twitter:title"
						content={publication.displayTitle || publication.title || 'Hashnode Blog Starter Kit'}
					/>
					<meta property="twitter:description" content={description} />
					<meta
						property="og:image"
						content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication) || undefined}
					/>
					<meta
						property="twitter:image"
						content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication) || undefined}
					/>
					<script
						type="application/ld+json"
						dangerouslySetInnerHTML={{
							__html: JSON.stringify(addPublicationJsonLd(publication)),
						}}
					/>
				</Head>
				<Header isHome={false} />
				<Container>
					<article className="flex flex-col items-start gap-10 pb-10">
						<Page {...props} />
					</article>
				</Container>
				<PublicationFooter
					authorName={publication.author.name}
					title={publication.title}
					imprint={publication.imprint}
					disableFooterBranding={publication.preferences.disableFooterBranding}
					isTeam={publication.isTeam}
					logo={publication.preferences.logo}
					darkMode={publication.preferences.darkMode}
				/>
			</Layout>
		</AppProvider>
	);
}

type Params = {
	slug: string;
};

export const getStaticProps: GetStaticProps<Props, Params> = async ({ params }) => {
	if (!params) {
		throw new Error('No params');
	}

	const endpoint = process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT;
	const host = process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST;
	const slug = params.slug;

	// If environment variables are not set, return not found
	if (!endpoint || !host) {
		console.warn('Hashnode environment variables not set, returning not found');
		return {
			notFound: true,
			revalidate: 1,
		};
	}

	const [postData, morePostsData] = await Promise.all([
		request(endpoint, SinglePostByPublicationDocument, { host, slug }),
		request(endpoint, MorePostsByPublicationDocument, { first: 4, host }),
	]);

	let recommendedPosts: MorePostsEdgeFragment[] = [];

	if (postData.publication?.post?.tags?.length) {
		const tagSlug = postData.publication.post.tags[0].slug;
		try {
			const recommendedPostsData = await request(endpoint, TagPostsByPublicationDocument, {
				host,
				tagSlug,
				first: 3,
			});
			recommendedPosts = recommendedPostsData.publication?.posts?.edges ?? [];
			// Filter out the current post
			recommendedPosts = recommendedPosts.filter((edge) => edge.node.id !== postData.publication?.post?.id);
		} catch (error) {
			console.warn('Failed to fetch recommended posts:', error);
		}
	}

	if (postData.publication?.post) {
		return {
			props: {
				type: 'post',
				post: postData.publication.post,
				morePosts: morePostsData.publication?.posts.edges ?? [],
				recommendedPosts,
				publication: postData.publication,
			},
			revalidate: 1,
		};
	}

	let pageData;
	try {
		pageData = await request(endpoint, PageByPublicationDocument, { host, slug });
	} catch (error) {
		console.warn('Failed to fetch page data:', error);
		return {
			notFound: true,
			revalidate: 1,
		};
	}

	if (pageData.publication?.staticPage) {
		return {
			props: {
				type: 'page',
				page: pageData.publication.staticPage,
				publication: pageData.publication,
			},
			revalidate: 1,
		};
	}

	return {
		notFound: true,
		revalidate: 1,
	};
};

export const getStaticPaths: GetStaticPaths = async () => {
	const endpoint = process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT;
	const host = process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST;

	// If environment variables are not set, return empty paths (build will still work)
	if (!endpoint || !host) {
		console.warn('Hashnode environment variables not set, returning empty paths for static generation');
		return {
			paths: [],
			fallback: 'blocking',
		};
	}

	try {
		const data = await request(
			endpoint,
			SlugPostsByPublicationDocument,
			{
				first: 10,
				host: host,
			},
		);

		const postSlugs = (data.publication?.posts.edges ?? []).map((edge) => edge.node.slug);

		return {
			paths: postSlugs.map((slug) => {
				return {
					params: {
						slug: slug,
					},
				};
			}),
			fallback: 'blocking',
		};
	} catch (error) {
		// If request fails, return empty paths (build will still work)
		console.warn('Failed to fetch static paths, using fallback:', error);
		return {
			paths: [],
			fallback: 'blocking',
		};
	}
};
